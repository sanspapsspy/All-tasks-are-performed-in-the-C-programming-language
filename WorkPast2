//7. Задан числовой массив. Переписать в новый массив числа, стоящие на нечётных позициях.
#include <stdio.h>
#include <stdlib.h>

void copy_odd_elements(int arr[], int size, int new_arr[]) {
    int new_size = 0;
    for (int i = 0; i < size; i++) {
        if (i % 2 != 0) {
            new_arr[new_size++] = arr[i];
        }
    }
}

int main() {
    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int size = sizeof(arr) / sizeof(arr[0]);
    int new_arr[size]; // Выделяем новый массив нужного размера
    int new_size = 0;
    copy_odd_elements(arr, size, new_arr);
    for (int i = 0; i < new_size; i++) {
        printf("%d ", new_arr[i]);
    }
    printf("\\n");
    return 0;
}


//1. В функции copy_odd_elements принимаются три аргумента:
//- int arr[] - исходный числовой массив.
//- int size - размер исходного массива.
//- int new_arr[] - массив, в который будут скопированы числа с нечётных позиций.
//2. Внутри функции copy_odd_elements используется цикл for (int i = 0; i < size; i++), который последовательно перебирает элементы исходного массива arr.
//3. Для каждого элемента проверяется, находится ли он на нечётной позиции (то есть i % 2 != 0). Если условие выполняется, то значение текущего элемента копируется в new_arr.
//4. Переменная new_size используется для отслеживания текущего размера нового массива new_arr, чтобы добавлять в него новые элементы.
//5. В функции main сначала создаётся исходный массив arr с элементами от 1 до 10.
//6. Вычисляется размер size исходного массива с помощью sizeof(arr) / sizeof(arr[0]).
//7. Создаётся новый массив new_arr размером size / 2, так как в новый массив будут скопированы только элементы с нечётными индексами.
//8. Вызывается функция copy_odd_elements(arr, size, new_arr), которая заполняет массив new_arr элементами с нечётными индексами из arr.
//9. В конце программы выводятся значения элементов из нового массива new_arr.

//8. Задан числовой массив. Переписать в новый массив чётные числа.

void copy_even_elements(int arr[], int size, int new_arr[]) {
    int new_size = 0;
    for (int i = 0; i < size; i++) {
        if (arr[i] % 2 == 0) {
            new_arr[new_size++] = arr[i];
        }
    }
}

int main() {
    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int size = sizeof(arr) / sizeof(arr[0]);
    int new_arr[size]; // Выделяем новый массив нужного размера
    int new_size = 0;
    copy_even_elements(arr, size, new_arr);
    for (int i = 0; i < new_size; i++) {
        printf("%d ", new_arr[i]);
    }
    printf("\\n");
    return 0;
}

//1. В функции copy_even_elements принимаются три аргумента:
//- int arr[] - исходный числовой массив.
//- int size - размер исходного массива.
//- int new_arr[] - массив, в который будут скопированы чётные числа.
//2. Внутри функции copy_even_elements используется цикл for (int i = 0; i < size; i++), который последовательно перебирает элементы исходного массива arr.
//3. Для каждого элемента проверяется, является ли он чётным (то есть arr[i] % 2 == 0). Если условие выполняется, то значение текущего элемента копируется в new_arr.
//4. Переменная new_size используется для отслеживания текущего размера нового массива new_arr, чтобы добавлять в него новые элементы.
//5. В функции main сначала создаётся исходный массив arr с элементами от 1 до 10.
//6. Вычисляется размер size исходного массива с помощью sizeof(arr) / sizeof(arr[0]).
//7. Создаётся новый массив new_arr размером size / 2, так как в новый массив будут скопированы только чётные элементы.
//8. Вызывается функция copy_even_elements(arr, size, new_arr), которая заполняет массив new_arr чётными элементами из arr.
//9. В конце программы выводятся значения элементов из нового массива new_arr.

//9. Дан массив значений типа double. Скопировать его в новый массив, удаляя повторяющиеся значения.
#include <stdio.h>
#include <stdlib.h>

int remove_duplicates(double arr[], int size, double new_arr[]) {
    int new_size = 0;
    for (int i = 0; i < size; i++) {
        int is_duplicate = 0;
        for (int j = 0; j < new_size; j++) {
            if (arr[i] == new_arr[j]) {
                is_duplicate = 1;
                break;
            }
        }
        if (!is_duplicate) {
            new_arr[new_size++] = arr[i];
        }
    }
    return new_size;
}

int main() {
    double arr[] = { 1.0, 2.0, 3.0, 2.0, 4.0, 5.0, 1.0, 6.0 };
    int size = sizeof(arr) / sizeof(arr[0]);
    double new_arr[size];
    int new_size = remove_duplicates(arr, size, new_arr);
    for (int i = 0; i < new_size; i++) {
        printf("%.1f ", new_arr[i]);
    }
    printf("\n");
    return 0;
}
//1. В функции remove_duplicates принимаются три аргумента:
//- double arr[] - исходный массив типа double.
//- int size - размер исходного массива.
//- double new_arr[] - массив, в который будут скопированы уникальные значения.
//2. Внутри функции remove_duplicates используется цикл for (int i = 0; i < size; i++), который последовательно перебирает элементы исходного массива arr.
//3. Для каждого элемента проверяется, является ли он дубликатом существующих элементов в new_arr. Это достигается с помощью вложенного цикла for (int j = 0; j < new_size; j++), который сравнивает текущий элемент arr[i] с каждым элементом new_arr[j].
//4. Если текущий элемент arr[i] является дубликатом, то флаг is_duplicate устанавливается в 1, и цикл проверки дубликатов прерывается с помощью break.
//5. Если элемент arr[i] не является дубликатом, то он копируется в new_arr, и new_size увеличивается на 1.
//6. После завершения внешнего цикла, функция remove_duplicates возвращает значение new_size, которое представляет количество уникальных элементов, скопированных в new_arr.
//7. В функции main сначала создаётся исходный массив arr с элементами типа double.
//8. Вычисляется размер size исходного массива с помощью sizeof(arr) / sizeof(arr[0]).
//9. Создаётся новый массив new_arr размером, равным размеру исходного массива arr.
//10. Вызывается функция remove_duplicates(arr, size, new_arr), которая заполняет массив new_arr уникальными элементами из arr.
//11. Возвращаемое значение new_size используется для вывода всех элементов из new_arr.

//10. Заданы две матрицы произвольного размера. Реализовать алгоритм умножения матриц. В случае, если умножение невозможно, необходимо сообщить пользователю об ошибке.
#include <stdio.h>
#include <stdlib.h>

int matrix_multiplication(double matrix1[][10], int rows1, int cols1,
    double matrix2[][10], int rows2, int cols2,
    double result[][10]) {
    if (cols1 != rows2) {
        printf("Error: Incompatible matrix dimensions for multiplication.\n");
        return 0;
    }

    for (int i = 0; i < rows1; i++) {
        for (int j = 0; j < cols2; j++) {
            result[i][j] = 0;
            for (int k = 0; k < cols1; k++) {
                result[i][j] += matrix1[i][k] * matrix2[k][j];
            }
        }
    }

    return 1;
}

int main() {
    double matrix1[10][10] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    double matrix2[10][10] = {
        {1, 4, 7},
        {2, 5, 8},
        {3, 6, 9}
    };
    double result[10][10];

    if (matrix_multiplication(matrix1, 3, 3, matrix2, 3, 3, result)) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                printf("%.1f ", result[i][j]);
            }
            printf("\n");
        }
    }

    return 0;
}
//1. В функции matrix_multiplication принимаются шесть аргумента :
//- double matrix1[][10] - первая матрица.
//- int rows1 - количество строк в первой матрице.
//- int cols1 - количество столбцов в первой матрице.
//- double matrix2[][10] - вторая матрица.
//- int rows2 - количество строк во второй матрице.
//- int cols2 - количество столбцов во второй матрице.
//- double result[][10] - матрица, в которую будет записан результат умножения.
//2. Первым делом проверяется, возможно ли умножение матриц. Для этого проверяется условие cols1 != rows2. Если условие не выполняется, то матрицы несовместимы для умножения, и функция возвращает 0 с выводом соответствующего сообщения об ошибке.
//3. Если матрицы совместимы для умножения, то функция выполняет вычисления по алгоритму перемножения матриц:
//- Внешний цикл for (int i = 0; i < rows1; i++) перебирает строки первой матрицы.
//- Внутренний цикл for (int j = 0; j < cols2; j++) перебирает столбцы второй матрицы.
//- Для каждой ячейки результирующей матрицы result[i][j] вычисляется скалярное произведение соответствующей строки первой матрицы и столбца второй матрицы.
//- Значения ячеек результирующей матрицы накапливаются в переменной result[i][j].
//4. После завершения вычислений функция возвращает 1, указывая, что умножение матриц прошло успешно.
//5. В функции main создаются две тестовые матрицы matrix1 и matrix2 размером 3x3.
//6. Создается матрица result размером 10x10, в которую будет записан результат умножения.
//7. Вызывается функция matrix_multiplication(matrix1, 3, 3, matrix2, 3, 3, result), передавая в нее исходные матрицы и размеры.
//8. Если функция вернула 1, то выводится результат умножения матриц.

//11. Реализовать функцию подсчета длины строки, аналогичную стандартной функции strlen.
#include <stdio.h>

int my_strlen(char* str) {
    int length = 0;

    while (*str != '\0') {
        length++;
        str++;
    }
    return length;
}

int main() {
    char str[] = "Hello, World!";
    printf("Length: %d\n", my_strlen(str));
    return 0;
}
//1. Функция my_strlen принимает один аргумент:
//- char *str - указатель на строку, длину которой нужно вычислить.
//2. Внутри функции объявляется переменная length, которая будет хранить длину строки.
//3. Используется цикл while (*str != '\0'), который продолжается, пока не будет достигнут конец строки (символ нуль-терминатора '\0').
//4. В каждой итерации цикла:
//- Значение length увеличивается на 1, чтобы посчитать длину строки.
//- Указатель str сдвигается на один элемент вперед, чтобы перейти к следующему символу в строке.
//5. После завершения цикла, функция my_strlen возвращает значение length, которое равно длине строки.
//6. В функции main создается строковый массив str со значением "Hello, World!".
//7. Вызывается функция my_strlen(str), которая вычисляет длину строки, и результат выводится на экран с помощью printf.

//12. Реализовать функцию поиска подстроки в строке, аналогичную стандартной функции strstr.
#include <stdio.h>

char* my_strstr(char* haystack, char* needle) {
    char* h = haystack;
    char* n = needle;

    while (*h != '\0') {
        char* start = h;
        while (*h == *n && *n != '\0') {
            h++;
            n++;
        }
        if (*n == '\0') {
            return start;
        }
        h = start + 1;
        n = needle;
    }

    return NULL;
}

int main() {
    char haystack[] = "Hello, World!";
    char needle[] = "World";
    char* result = my_strstr(haystack, needle);
    if (result != NULL) {
        printf("Substring found: %s\n", result);
    }
    else {
        printf("Substring not found.\n");
    }
    return 0;
}
//1. В функции copy_even_elements принимаются три аргумента:
//- int arr[] - исходный числовой массив.
//- int size - размер исходного массива.
//- int new_arr[] - массив, в который будут скопированы чётные числа.
//2. Внутри функции copy_even_elements используется цикл for (int i = 0; i < size; i++), который последовательно перебирает элементы исходного массива arr.
//3. Для каждого элемента проверяется, является ли он чётным (то есть arr[i] % 2 == 0). Если условие выполняется, то значение текущего элемента копируется в new_arr.
//4. Переменная new_size используется для отслеживания текущего размера нового массива new_arr, чтобы добавлять в него новые элементы.
//5. В функции main сначала создаётся исходный массив arr с элементами от 1 до 10.
//6. Вычисляется размер size исходного массива с помощью sizeof(arr) / sizeof(arr[0]).
//7. Создаётся новый массив new_arr размером size / 2, так как в новый массив будут скопированы только чётные элементы.
//8. Вызывается функция copy_even_elements(arr, size, new_arr), которая заполняет массив new_arr чётными элементами из arr.
//9. В конце программы выводятся значения элементов из нового массива new_arr.
