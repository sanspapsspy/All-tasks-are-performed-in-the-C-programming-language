1. Implement a bubble sorting algorithm for an array of numbers
void bubble_sort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Меняем местами arr[j] и arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
//Этот алгоритм работает, последовательно сравнивая соседние элементы массива и меняя их местами, 
//если они находятся в неправильном порядке. Благодаря этому, наибольшие элементы "всплывают" в конец массива, 
//и алгоритм повторяется, пока весь массив не будет отсортирован.
//Алгоритм сортировки пузырьком работает следующим образом:
//1. Оператор for (int i = 0; i < size - 1; i++) проходит по массиву arr size - 1 раз. Это внешний цикл, который отвечает за количество проходов по массиву.
//2. Внутренний цикл for (int j = 0; j < size - i - 1; j++) проходит по массиву от начала до конца минус i элементов. Это связано с тем, что после каждого прохода внешнего цикла, наибольший элемент перемещается в конец массива, и нет необходимости сравнивать его с последующими элементами.
//3. Внутри внутреннего цикла выполняется проверка if (arr[j] > arr[j + 1]). Если текущий элемент массива больше следующего, то они меняются местами с помощью временной переменной temp.
//4. В результате выполнения этой программы, массив arr будет отсортирован по возрастанию с помощью алгоритма сортировки пузырьком.
//Основная идея алгоритма состоит в последовательном сравнении соседних элементов и перемещении больших элементов к концу массива. Это происходит на каждом проходе внешнего цикла, пока весь массив не будет отсортирован.

2. Implement the “reverse” algorithm of a character string
void reverse_string(char *str) {
    int i, j;
    char temp;
    for (i = 0, j = strlen(str) - 1; i < j; i++, j--) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
}
//Этот алгоритм использует два указателя, 
//которые двигаются навстречу друг другу, меняя местами символы в начале и конце строки. 
//Таким образом, строка "переворачивается".
//1. Функция принимает на вход указатель на строку char *str.
//2. Внутри функции объявляются две локальные переменные int i и int j, а также временная переменная char temp.
//3. Цикл for (i = 0, j = strlen(str) - 1; i < j; i++, j--) инициализирует два указателя - i в начало строки и j в конец строки.
//4. Внутри цикла происходит обмен символов, расположенных на позициях i и j в строке:
//   - Текущее значение str[i] сохраняется во временную переменную temp.
//   - Значение str[j] копируется в str[i].
//   - Значение из temp (изначальное значение str[i]) копируется в str[j].
//5. Циклы продолжаются, пока указатель i не станет больше или равен указателю j, т.е. пока мы не "переверните" всю строку.


3. Implement a function that swaps the values of two int numbers. The input parameters of the function are pointers of the int* type.
//
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
//Эта функция использует указатели на int для доступа к значениям переменных, которые нужно поменять местами. 
//Она использует временную переменную для хранения значения первой переменной, а затем меняет значения обеих переменных.
//1. Функция принимает два входных параметра - указатели типа int *a и int *b.
//2. Внутри функции объявляется временная переменная int temp, в которую сохраняется значение, на которое указывает указатель *a.
//3. Затем значение, на которое указывает *a, заменяется на значение, на которое указывает *b.
//4. И наконец, значение, на которое указывает *b, заменяется на значение, сохраненное во временной переменной temp.
//Таким образом, в результате выполнения этой функции, значения двух целочисленных переменных, на которые указывают *a и *b, меняются местами.
//This function fills the array with pseudo-random integers in the range [-10000, 10000], 
//and then finds the indexes of the minimum and maximum elements in one pass through the array.


4. Filling the array with pseudo-random integers and searching for the maximum and minimum in C:
#include <stdlib.h>

void fill_array_and_find_minmax(int arr[], int size, int *min_idx, int *max_idx) {
    *min_idx = 0;
    *max_idx = 0;

    for (int i = 0; i < size; i++) {
        arr[i] = rand() % 20001 - 10000; // Диапазон [-10000, 10000]
        if (arr[i] < arr[*min_idx]) {
            *min_idx = i;
        }
        if (arr[i] > arr[*max_idx]) {
            *max_idx = i;
        }
    }
}
//1. Функция принимает следующие аргументы:
//- int arr[] - массив целых чисел, который будет заполнен.
//- int size - размер массива.
//- int *min_idx - указатель на целочисленную переменную, в которую будет записан индекс минимального элемента.
//- int *max_idx - указатель на целочисленную переменную, в которую будет записан индекс максимального элемента.
//2. Внутри функции, переменные *min_idx и *max_idx инициализируются значением 0, так как предполагается, что первый элемент массива является минимальным и максимальным.
//3. Далее в цикле for (int i = 0; i < size; i++) происходит заполнение массива arr псевдослучайными целыми числами в диапазоне от -10000 до 10000 (включительно).
//4. Внутри цикла также выполняется поиск минимального и максимального элементов массива:
//- Если текущий элемент arr[i] меньше элемента, на который указывает *min_idx, то *min_idx обновляется на i.
//- Если текущий элемент arr[i] больше элемента, на который указывает *max_idx, то *max_idx обновляется на i



5. Binary search for an element in an array of integers in C:
int binary_search(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Элемент не найден
}
//Этот алгоритм двоичного поиска последовательно сужает диапазон поиска, 
//деля его пополам на каждом шаге, пока не найдет искомый элемент или не убедится, что он отсутствует в массиве.
//1. Функция принимает три аргумента:
//- int arr[] - упорядоченный массив целых чисел, в котором необходимо выполнить поиск;
//- int size - размер массива arr;
//- int target - значение, которое необходимо найти в массиве.
//2. Переменные int left и int right инициализируются значениями 0 и size - 1 соответственно. Они обозначают начальный и конечный индексы диапазона поиска.
//3. Цикл while (left <= right) продолжается, пока левая граница диапазона left не станет больше правой right.
//4. Внутри цикла вычисляется средний индекс int mid = left + (right - left) / 2. Это позволяет избежать возможного переполнения при вычислении (left + right) / 2.
//5. Затем выполняется проверка значения элемента массива, расположенного по индексу mid:
//- Если arr[mid] == target, то элемент найден, и функция возвращает mid - индекс найденного элемента.
//- Если arr[mid] < target, то искомый элемент находится в правой половине массива, поэтому left обновляется на mid + 1.
//- Если arr[mid] > target, то искомый элемент находится в левой половине массива, поэтому right обновляется на mid - 1.
//6. Если в результате поиска элемент не был найден, функция возвращает -1 - значение, указывающее на то, что элемент не был обнаружен в массиве.

6. Calculating the determinant of a square matrix in C:
#include <math.h>

double determinant(double matrix[size][size], int size) {
    if (size == 1) {
        return matrix[0][0];
    } else if (size == 2) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
    } else {
        double det = 0;
        for (int i = 0; i < size; i++) {
            double submatrix[size - 1][size - 1];
            for (int j = 1; j < size; j++) {
                for (int k = 0; k < i; k++) {
                    submatrix[j - 1][k] = matrix[j][k];
                }
                for (int k = i + 1; k < size; k++) {
                    submatrix[j - 1][k - 1] = matrix[j][k];
                }
            }
            det += (i % 2 == 0 ? 1 : -1) * matrix[0][i] * determinant(submatrix, size - 1);
        }
        return det;
    }
}
//Этот алгоритм вычисляет определитель квадратной матрицы рекурсивно, используя свойство определителя матрицы. 
//Для матриц размера 1x1 и 2x2 определитель вычисляется напрямую, а для более крупных матриц рекурсивно вычисляется определитель подматриц размером (n-1)x(n-1).
//1. Функция determinant принимает два аргумента:
//- double matrix[size][size] - двумерный массив, представляющий квадратную матрицу.
//- int size - размер матрицы (количество строк и столбцов).
//2. Функция использует рекурсивный подход для вычисления определителя матрицы:
//- Если размер матрицы равен 1, то определитель просто равен единственному элементу матрицы.
//- Если размер матрицы равен 2, то определитель вычисляется как matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0].
//- Для матриц большего размера (больше 2), определитель вычисляется с помощью разложения Лапласа по первой строке:
//- Для каждого элемента первой строки вычисляется определитель соответствующей подматрицы размером size - 1 (без текущей строки и столбца).
//- Каждое значение определителя подматрицы умножается на соответствующий элемент первой строки, при этом знак меняется на противоположный для элементов с нечетными индексами.
//- Полученные произведения суммируются, и результат является значением определителя исходной матрицы.
//3. Рекурсивный вызов determinant(submatrix, size - 1) используется для вычисления определителей подматриц размером size - 1.


