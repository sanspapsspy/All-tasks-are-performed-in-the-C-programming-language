//13.Имеется строка. Используя указатель типа char *, преобразовать каждый элемент, стоящий
//на нечётной позиции, в верхний регистр.
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void convert_to_uppercase(char *str) {
    char *ptr = str;
    int i = 0;
    while (*ptr != '\0') {
        if (i % 2 != 0) {
            *ptr = toupper(*ptr);
        }
        ptr++;
        i++;
    }
}

int main() {
    char str[] = "Hello, World!";
    printf("Original string: %s\n", str);
    convert_to_uppercase(str);
    printf("Modified string: %s\n", str);
    return 0;
}
//1. В функции convert_to_uppercase принимается один аргумент:
//- char *str - указатель на строку, которую нужно модифицировать.
//2. Внутри функции создаются два указателя:
//- char *ptr = str - указатель, который будет использоваться для перемещения по строке.
//- int i = 0 - счетчик, который будет использоваться для определения четности позиции.
//3. Основной цикл while (*ptr != '\0') продолжается, пока не достигнут конец строки (символ нуль-терминатора '\0').
//4. В каждой итерации цикла:
//- Проверяется, находится ли счетчик i на нечетной позиции (i % 2 != 0).
//- Если да, то текущий символ, на который указывает ptr, преобразуется в верхний регистр с помощью функции toupper(*ptr).
//- Указатель ptr сдвигается на один символ вперед.
//- Счетчик i увеличивается на 1.
//5. В функции main создается строковый массив str со значением "Hello, World!".
//6. Выводится исходная строка с помощью printf("Original string: %s\n", str).
//7. Вызывается функция convert_to_uppercase(str), которая модифицирует строку, преобразуя символы на нечетных позициях в верхний регистр.
//8. Выводится модифицированная строка с помощью printf("Modified string: %s\n", str)

//14.В текстовом файле задан целочисленный массив. Разделительный символ между
//значениями – пробел. Файл корректный. Необходимо считать данные из файла, заполнить
//массив и найти в этом массиве максимальный и минимальные элементы
#include <stdio.h>
#include <stdlib.h>

int my_atoi(const char *str) {
    int result = 0;
    while (*str != '\0') {
        if (*str >= '0' && *str <= '9') {
            result = result * 10 + (*str - '0');
            str++;
        } else {
            str++;
        }
    }
    return result;
}

int main() {
    FILE *fp = fopen("input.txt", "r");
    if (fp == NULL) {
        printf("Error opening file.\n");
        return 1;
    }

    int arr[100];
    int i = 0;
    char buffer[100];
    while (fgets(buffer, 100, fp) != NULL) {
        char *token = strtok(buffer, " ");
        while (token != NULL) {
            arr[i++] = my_atoi(token);
            token = strtok(NULL, " ");
        }
    }

    int max = arr[0], min = arr[0];
    for (int j = 1; j < i; j++) {
        if (arr[j] > max) {
            max = arr[j];
        }
        if (arr[j] < min) {
            min = arr[j];
        }
    }

    printf("Maximum element: %d\n", max);
    printf("Minimum element: %d\n", min);

    fclose(fp);
    return 0;
}
//1. Функция my_atoi используется для преобразования строки в целое число. Она принимает один аргумент:
//- const char *str - указатель на строку, которую нужно преобразовать.
//2. Внутри функции my_atoi создается переменная result, которая будет хранить результат преобразования.
//3. Используется цикл while (*str != '\0'), который продолжается, пока не будет достигнут конец строки (символ нуль-терминатора '\0').
//4. В каждой итерации цикла:
//- Проверяется, является ли текущий символ цифрой (*str >= '0' && *str <= '9').
//- Если да, то значение result умножается на 10 и к нему прибавляется соответствующая цифра (*str - '0').
//- Указатель str сдвигается на один символ вперед.
//- Если текущий символ не является цифрой, то указатель str просто сдвигается на один символ вперед.
//5. В функции main:
//- Открывается файл input.txt в режиме чтения.
//- Если файл не может быть открыт, выводится сообщение об ошибке и программа завершается.
//- Создается массив arr размером 100 элементов для хранения чисел из файла.
//- Используется цикл while (fgets(buffer, 100, fp) != NULL), который читает строки из файла.
//- Для каждой строки вызывается функция strtok, чтобы разбить ее на токены, разделенные пробелами.
//- Для каждого токена вызывается функция my_atoi, чтобы преобразовать его в целое число, и результат сохраняется в массиве arr.
//- Далее выполняется поиск максимального и минимального элементов в массиве arr.
//- Найденные максимальный и минимальный элементы выводятся на экран.
//- Файл закрывается.

//15.Задана строка символов. Используя указатели, переписать строку так, чтобы в начале
//строки были символы цифр, затем символы букв латинского алфавита, а в самом конце –
//прочие символы; порядок следования цифр/букв латинского алфавита/прочих символов
//при этом сохранить
#include <stdio.h>
#include <ctype.h>

void rearrange_string(char *str) {
    char *digits = str;
    char *letters = str;
    char *others = str;

    while (*others != '\0') {
        if (isdigit(*others)) {
            *digits++ = *others++;
        } else if (isalpha(*others)) {
            *letters++ = *others++;
        } else {
            *others++;
        }
    }

    *letters = '\0';
    *others = '\0';
}

int main() {
    char str[] = "a1b2c3D4E5f";
    printf("Original string: %s\n", str);
    rearrange_string(str);
    printf("Rearranged string: %s\n", str);
    return 0;
}
//1. В функции rearrange_string принимается один аргумент:
//- char *str - указатель на строку, которую нужно модифицировать.
2. Внутри функции создаются три указателя:
//- char *digits = str - указатель на начало строки, который будет использоваться для копирования цифр.
//- char *letters = str - указатель на начало строки, который будет использоваться для копирования букв.
//- char *others = str - указатель на начало строки, который будет использоваться для перемещения по строке.
//3. Используется цикл while (*others != '\0'), который продолжается, пока не достигнут конец строки (символ нуль-терминатора '\0').
//4. В каждой итерации цикла:
//- Проверяется, является ли текущий символ, на который указывает others, цифрой (isdigit(*others)).
//- Если да, то текущий символ копируется в позицию, на которую указывает digits, и оба указателя (digits и others) сдвигаются на один символ вперед.
//- Если текущий символ является буквой (isalpha(*others)), то он копируется в позицию, на которую указывает letters, и оба указателя (letters и others) сдвигаются на один символ вперед.
//- Если текущий символ не является цифрой или буквой, то он просто пропускается, и указатель others сдвигается на один символ вперед.
//5. После завершения цикла, указатели letters и others устанавливаются в конец строки, чтобы обозначить конец последовательностей цифр и букв соответственно.
//6. В функции main создается строковый массив str со значением "a1b2c3D4E5f".
//7. Выводится исходная строка с помощью printf("Original string: %s\n", str).
//8. Вызывается функция rearrange_string(str), которая модифицирует строку, перегруппировывая цифры, буквы и прочие символы.
//9. Выводится модифицированная строка с помощью printf("Rearranged string: %s\n", str).


//16. Задана строка символов. Используя указатели, исключить из строки все символы
#include <stdio.h>

void remove_characters(char *str, char *to_remove) {
    char *src = str;
    char *dst = str;

    while (*src != '\0') {
        if (strchr(to_remove, *src) == NULL) {
            *dst++ = *src;
        }
        src++;
    }

    *dst = '\0';
}

int main() {
    char str[] = "Hello, World!";
    char to_remove[] = ",!";
    printf("Original string: %s\n", str);
    remove_characters(str, to_remove);
    printf("Modified string: %s\n", str);
    return 0;
}
//1. В функции remove_characters принимаются два аргумента:
//- char *str - указатель на строку, из которой нужно удалить символы.
//- char *to_remove - указатель на строку, содержащую символы, которые нужно удалить из первой строки.
//2. Внутри функции создаются два указателя:
//- char *src = str - указатель, который будет использоваться для перемещения по исходной строке.
//- char *dst = str - указатель, который будет использоваться для формирования модифицированной строки.
//3. Используется цикл while (*src != '\0'), который продолжается, пока не достигнут конец строки (символ нуль-терминатора '\0').
//4. В каждой итерации цикла:
//- Проверяется, содержится ли текущий символ, на который указывает src, в строке to_remove с помощью функции strchr(to_remove, *src).
//- Если символ не найден в to_remove, то он копируется в позицию, на которую указывает dst, и оба указателя (dst и src) сдвигаются на один символ вперед.
//- Если символ найден в to_remove, то указатель src просто сдвигается на один символ вперед, без копирования.
//5. После завершения цикла, в позицию, на которую указывает dst, записывается символ нуль-терминатора '\0', чтобы обозначить конец модифицированной строки.
//6. В функции main создается строковый массив str со значением "Hello, World!" и строковый массив to_remove со значением ",!".
//7. Выводится исходная строка с помощью printf("Original string: %s\n", str).
//8. Вызывается функция remove_characters(str, to_remove), которая модифицирует строку str, удаляя из нее все символы, содержащиеся в to_remove.
//9. Выводится модифицированная строка с помощью printf("Modified string: %s\n", str).

//17. Реализовать функцию конкатенации строк, аналогичную стандартной функции strcat.
#include <stdio.h>
#include <string.h>

char *my_strcat(char *dest, const char *src) {
    char *ptr = dest;
    while (*ptr != '\0') {
        ptr++;
    }

    while (*src != '\0') {
        *ptr++ = *src++;
    }

    *ptr = '\0';
    return dest;
}

int main() {
    char dest[100] = "Hello, ";
    char src[] = "World!";
    printf("Concatenated string: %s\n", my_strcat(dest, src));
    return 0;
}
//1. В функции my_strcat принимаются два аргумента:
//- char *dest - указатель на строку, к которой будет добавляться другая строка.
//- const char *src - указатель на строку, которую нужно добавить к dest.
//2. Внутри функции создается указатель char *ptr = dest, который будет использоваться для перемещения по строке dest.
//3. Цикл while (*ptr != '\0') продолжается, пока не достигнут конец строки dest (символ нуль-терминатора '\0'). Во время этого цикла указатель ptr перемещается к концу строки dest.
//4. После этого начинается второй цикл while (*src != '\0'), который копирует символы из строки src в строку dest, начиная с конца dest. В каждой итерации цикла:
//- Текущий символ, на который указывает src, копируется в позицию, на которую указывает ptr.
//- Оба указателя (ptr и src) сдвигаются на один символ вперед.
//5. После завершения второго цикла, в позицию, на которую указывает ptr, записывается символ нуль-терминатора '\0', чтобы обозначить конец модифицированной строки dest.
//6. Функция my_strcat возвращает указатель на модифицированную строку dest.
//7. В функции main создается строка dest со значением "Hello, " и строка src со значением "World!".
//8. Вызывается функция my_strcat(dest, src), которая конкатенирует (объединяет) строки dest и src, и результат выводится на экран с помощью printf("Concatenated string: %s\n", ...).


//18. Дана квадратная матрица. Реализовать алгоритм транспонирования матрицы. 
#include <stdio.h>

void transpose_matrix(int matrix[][10], int size) {
    for (int i = 0; i < size; i++) {
        for (int j = i; j < size; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}

int main() {
    int matrix[10][10] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    int size = 3;
    printf("Original matrix:\n");
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    transpose_matrix(matrix, size);

    printf("Transposed matrix:\n");
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }

    return 0;
}

//1. В функции transpose_matrix принимаются два аргумента:
//- int matrix[][10] - двумерный массив, представляющий матрицу, которую нужно транспонировать.
//- int size - размер матрицы (количество строк и столбцов).
//2. Используется вложенный цикл, который проходит по всем элементам матрицы:
//- Внешний цикл for (int i = 0; i < size; i++) перебирает строки матрицы.
//- Внутренний цикл for (int j = i; j < size; j++) перебирает столбцы матрицы, начиная с диагонального элемента (j >= i).
//3. В каждой итерации внутреннего цикла выполняются следующие действия:
//- Создается временная переменная int temp, в которую сохраняется значение элемента matrix[i][j].
//- Значение элемента matrix[i][j] заменяется на значение элемента matrix[j][i].
//- Значение элемента matrix[j][i] заменяется на значение, сохраненное в temp.
//4. В функции main создается матрица размером 3x3 и инициализируется значениями.
//5. Выводится исходная матрица с помощью вложенных циклов for, которые перебирают все элементы матрицы и выводят их на экран.
//6. Вызывается функция transpose_matrix(matrix, 3), которая транспонирует матрицу matrix.

//19. Дана квадратная матрица. Реализовать алгоритм нахождения обратной матрицы. 
#include <stdio.h>
#include <stdlib.h>

#define SIZE 3

double determinant(double matrix[SIZE][SIZE], int size) {
    if (size == 1) {
        return matrix[0][0];
    }
    if (size == 2) {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
    }
    double det = 0;
    for (int i = 0; i < size; i++) {
        double submatrix[SIZE][SIZE];
        for (int j = 1; j < size; j++) {
            int col = 0;
            for (int k = 0; k < size; k++) {
                if (k != i) {
                    submatrix[j - 1][col++] = matrix[j][k];
                }
            }
        }
        det += (i % 2 == 0 ? 1 : -1) * matrix[0][i] * determinant(submatrix, size - 1);
    }
    return det;
}

void inverse_matrix(double matrix[SIZE][SIZE], double result[SIZE][SIZE], int size) {
    double det = determinant(matrix, size);
    if (det == 0) {
        printf("Matrix is not invertible.\n");
        return;
    }
    double adj[SIZE][SIZE];
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            double submatrix[SIZE][SIZE];
            for (int k = 0; k < size; k++) {
                for (int l = 0; l < size; l++) {
                    if (k != i && l != j) {
                        submatrix[k < i ? k : k - 1][l < j ? l : l - 1] = matrix[k][l];
                    }
                }
            }
            adj[j][i] = (i + j) % 2 == 0 ? determinant(submatrix, size - 1) : -determinant(submatrix, size - 1);
        }
    }
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            result[i][j] = adj[i][j] / det;
        }
    }
}

int main() {
    double matrix[SIZE][SIZE] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    double result[SIZE][SIZE];
    inverse_matrix(matrix, result, SIZE);
    printf("Inverse matrix:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%.2f ", result[i][j]);
        }
        printf("\n");
    }
    return 0;
}
//1. Функция determinant вычисляет определитель квадратной матрицы.
//- Если размер матрицы равен 1, то возвращается просто этот элемент.
//- Если размер матрицы равен 2, то вычисляется определитель по формуле a11 * a22 - a12 * a21.
//- Для больших матриц вычисление производится рекурсивно: создается подматрица, исключающая текущую строку и столбец, и вычисляется определитель этой подматрицы. Далее результат складывается с произведением текущего элемента и соответствующего алгебраического дополнения.
//2. Функция inverse_matrix находит обратную матрицу.
//- Вычисляется определитель исходной матрицы с помощью функции determinant.
//- Если определитель равен 0, то матрица не является обратимой, и программа выводит сообщение.
//- Если определитель не равен 0, то вычисляются алгебраические дополнения для каждого элемента матрицы.
//- Полученная матрица алгебраических дополнений транспонируется, и каждый ее элемент делится на определитель исходной матрицы, чтобы получить обратную матрицу.
//3. В функции main создается исходная матрица размера 3x3 и вызывается функция inverse_matrix для ее инвертирования.
//4. Результат вычисления обратной матрицы выводится на экран.

//20. Преобразование числа из десятичной системы в систему с основанием от 2 до 36
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char* convert_to_base(int num, int base) {
    char* digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    char* result = (char*)malloc(sizeof(char) * 33);
    int i = 0;
    if (num == 0) {
        result[i++] = '0';
    } else {
        while (num > 0) {
            result[i++] = digits[num % base];
            num /= base;
        }
    }
    result[i] = '\0';
    char temp;
    for (int j = 0; j < i / 2; j++) {
        temp = result[j];
        result[j] = result[i - 1 - j];
        result[i - 1 - j] = temp;
    }
    return result;
}

int main() {
    int num = 123;
    int base = 16;
    char* result = convert_to_base(num, base);
    printf("%d in base %d is %s\n", num, base, result);
    free(result);
    return 0;
}
//1. Функция convert_to_base принимает два аргумента: num - исходное число в десятичной системе, base - система счисления, в которую нужно преобразовать число.
//2. Создается строка digits, содержащая все возможные цифры и буквы, используемые в системах счисления от 2 до 36.
//3. Выделяется динамическая память для строки результата размером 33 символа (максимальная длина двоичного представления 64-битного числа).
//4. Если число num равно 0, то в строку результата записывается '0'.
//5. В противном случае, в цикле while (num > 0) выполняется следующее:
//- Последняя цифра числа num по модулю base добавляется в строку результата.
//- Число num делится на base и обновляется.
//6. После окончания цикла, строка результата реверсируется, чтобы получить правильный порядок цифр.
//7. Возвращается указатель на строку результата.
//8. В функции main демонстрируется использование функции convert_to_base: число 123 преобразуется в шестнадцатеричную систему счисления.
